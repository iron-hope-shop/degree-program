- How will you apply this concept to your own practice?
- How would you explain this to a new developer on your team?
- What is one example of this concept you can use in your final reflection in Module Eight?

The motivation of hackers ranges from money to political gain.  Hackers can be individuals, companies, or even governments.  Understanding these vast multitude of motivators, we can can reduce the appeal of targets.  People are our weakest links and we can keep high profile employees from being spear phished by creating dummy accounts in the event of a breach.  We can also focus more resources on these employees when it comes to security training; however, all it takes for a hacker to breach a company is to find one weak link.  So in order to minimize risk we must also implement the defense in depth methodology.  Firewalls, least privelidge, SOC/SIRT monitoring and failsafes should be considered when standing up IT infrastructure, not afterward.  When it comes to existing companies, I would explain to a new employee of an existing company that all it takes for a hacker to perform a breach is a minor lapse in judgement.  If you click a malicious link without regard of the consequences, you are the weakest link.  Also it is important to keep intellectual property and trade secrets-- as secrets.  Publicly broadcasting the value or nature of your IP could make you a target.  In the end, hacks are inevitable even for small or burgeoning companies because for a small or burgeoning hacker, they would be a huge win if compromised.  They could earn reputation on darkweb forums and move on to perform bigger and more consequential breaches.

One example of hacker motivation is monitary value.  This applies to our final reflection such that if both risk and benefit of mitigation are low, inversely, the target is probably not appealing to a hacker.  For example, in my coding standards I defined STD-001-CPP (never qualify a reference type with const or volatile) as being low risk and low remediation cost.  This is because trying to qualify a reference type with const or volatile would trigger a compiler warning.  This would easy for even a beignner developer to address since it would be spelled out for them.  It also is very unlikely to be taken advantage of by a hacker since the ill-formed application that compiled regardless of the warning still functions within the realm of normalcy.