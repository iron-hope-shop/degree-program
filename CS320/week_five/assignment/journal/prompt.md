The software testing techniques that I employed for each of the milestones revolved around the use of JUnit tests.  I built tests based on customer requirements, performed static testing, and dynamic testing.  After the initial creation of the object models and services, I visually inspected the code.  I was able to correct some typing errors this way.  After that I created the tests based on customer requirements and did the same thing.  Once static testing was complete, I performed dynamic testing via JUnit tests.  This was a very easy way to test customer requirements during runtime.

Software testing techniques that I did not use for the milestones include decision tables, black box testing, and peer review (to name a few).  Decision tables are created to outline the number of possible inputs.  I did not do this, I simply embedded rules in the object models based on customer requirements.  Because I knew the inner workings of the application, black box testing was not possible.  This is where a third-party tests the application with little-to-no information.  Peer review was also not a possible means of testing this software because I am completing the project alone.  Otherwise, peer review would be a great way to find flaws in the software that would otherwise remain unseen.